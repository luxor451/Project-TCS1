
## Documentation
Before all, run the `cargo doc --open` command to generate the documentation and open the index.html file in your browser.

## Project Structure
This project, since it is in Rust, does not respect the structure given in the subject.

## Usage
To use Prim's algorithm, you should use the main i.e. run `cargo run --release --bin projet -- filename`. This will display in the terminal the maze generated with `prim_naive`, `prim_bh` and `wilson's algorithm`. The maze should not be too big to fit in the terminal. The maze generated by `prim_bh` and `wilson's algorithm` will also be written in a pbm file.

## Testing
For the tests use `cargo test`. They are located in the different files as private modules. 

To note: the test for `heap_complexity`, given its runtime is ignored by `cargo test`, you can still run it manually with `cargo test heap_complexity -- --ignored`. It is located in the `binary_heap.rs` file.

For the complexity, I created my own Python script that shows that results are $nln(n)$ and not $n^2$.

## Wilson's Algorithm
This project also implements Wilson's algorithm and writes its result to the standard output and to the `print_maze_wilson.pbm` file.

## Video
The `wilson_algorithm_with_root_with_video` function executes the Wilson algorithm and creates a video of the execution. The video is in the project folder and is named `maze_generation.mp4`.

To use it, you can add the 'video' argument to the command line when running the project. Example that you can run in the terminal: `cargo run --release --bin projet -- ./data/map_10_8_42.txt video`.

The video is created with ffmpeg. You need to make sure you have it installed on your computer. (I didn't have the time to test it on the school computer so I can't guarantee it will work on it)

If you have the time, I would recommend you to run it on the 100*100 because as it's most interesting on bigger mazes it will take some time though (around 15 minutes on my computer). You can obviously run it with the 10*8 maze but I find it less interesting. It will create a temporary folder to act as a buffer during the execution and remove it at the end.

## Complexity
The complexity for the functions is $nlog(n)$ because we call $n$ times a function that has a $O(ln(i))$ complexity where $i$ is the number of nodes at the current execution and:

$$
 \sum_{i = 0}^{n} ln(i) 
 = ln(n!)
$$

<center>Using Stirling's formula:</center>

$$
n! \approx \sqrt{2\pi n} (\frac{n}{e} )^{n}
$$

<center>We have:</center>

$$
ln(n!) \approx ln(\sqrt{2\pi n} (\frac{n}{e} )^{n})
$$
$$
ln(n!) \approx nln(n) + ln(\sqrt{2\pi n}{e} ^{-n})
$$
$$
ln(n!) \approx nln(n) - n + ln(\sqrt{2\pi n})
$$

$$
ln(n!) = O(nln(n))
$$